// ************************************************************************** //
// Unit.java - This class is a member of the Counters package, which contains //
//             the class definitions and implementations for objects used to  //
//             to represent the virtual playing pieces in jASL.               //
//                                                                            //
//             NOTE: This program is based on Advanced Squad Leader, a        //
//                   product of The Avalon Hill Game Company.                 //
//                                                                            //
// Written By: Craig R. Campbell  -  December 1998                            //
//                                                                            //
// $Header: /tmp/java/jasl.cvs/jasl/source/jasl/counters/Unit.java,v 1.6 2001/12/08 06:45:34 craig Exp $
// ************************************************************************** //

package Counters;

// ************************************************************************** //
// Unit class - This is the top-level class of the Counters package. All      //
//              the classes in this Package are derived from Unit.            //
// ************************************************************************** //

public abstract class Unit implements Counter
{
	// Protected symbolic constants

	// These constants are available to all subclasses and are used to define
	// the default return values / settings for the public methods defined in
	// this class (see comment below) or in its subclasses.

	protected static final int     DEFAULT_INT_VALUE    = 0;
	protected static final boolean DEFAULT_FLAG_VALUE   = false;
	protected static final String  DEFAULT_STRING_VALUE = "Unknown";

	// Private symbolic constants

	private static final String CLASS_NAME = "Unit";

	// Private data members

	// This variable contains a descriptive name for the derived object of this
	// class. It is typically set to the name of the child class being
	// instantiated (ie. "Squad").

	private String description;

	// The following strings are used as messages for any exceptions that may be
	// generated by bad data being passed to the protected constructor.

	private static final String nullArgumentError =
		buildErrorMessage(CLASS_NAME,CONSTRUCTOR,NULL_PARAMETER_MSG);

	private static final String zeroLengthArgumentError =
		buildErrorMessage(CLASS_NAME,CONSTRUCTOR,ZERO_LENGTH_PARAMETER_MSG);

	private static final String invalidArgumentError =
		buildErrorMessage(CLASS_NAME,CONSTRUCTOR,INVALID_PARAMETER_MSG);

	// Constructors

	// Default constructor. This is used to create arrays of this data type
	// which can be used to reference groups of objects derived from Unit.

	public Unit() {}

	// This constructor is used during the instantiation of classes derived
	// from Unit. The parameter is passed up the chain from the object being
	// created.

	protected Unit(String description)
	{
		// Check the input value for any problems and throw the appropriate
		// exception if necessary.

		if (description == null)
		{
			throw new NullPointerException(nullArgumentError);
		}

		if (description.length() == 0)
		{
			throw new IllegalArgumentException(zeroLengthArgumentError);
		}

		// Check the description parameter against the valid entries list and
		// set the local copy if it is valid.

		if (DESCRIPTIONS_VECTOR.contains(description))
		{
			this.description = description;
		}

		// Throw an exception if a match was not found.

		else
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                   description);
		}
	}

	// Public static methods

	// buildErrorMessage - A method to create the error messages included with
	//                     exceptions thrown by classes in this package.

	public static final String buildErrorMessage(String className,
	                                             String methodName,
	                                             String message)
	{
		// Create a buffer to store the new error message.

		StringBuffer errorString = new StringBuffer();

		// Add the class name specified to the buffer after verifying it.

		if ((className != null) && (className.length() > 0))
		{
			errorString.append(className);
		}

		// After verifying the method name specified, add it to the buffer in
		// a set of parentheses.

		if ((methodName != null) && (methodName.length() > 0))
		{
			errorString.append('(');
			errorString.append(methodName);
			errorString.append(')');
		}

		// Add the message specified to the buffer after verifying it.

		if ((message != null) && (message.length() > 0))
		{
			errorString.append(" - ");
			errorString.append(message);
		}

		// Return the completed string to calling program.

		return (errorString.toString());
	}

	// formatTextString - A method to create a formatted version of the input
	//                    string by appending spaces as necessary to make the
	//                    length equal to the specified value. If the string is
	//                    a label, the second to last character will be set to a
	//                    ":". The last character will always be set to a SPACE.

	public static final String formatTextString(String inputString,
	                                            int columnWidth,
	                                            boolean isALabel,
	                                            boolean addNewLine)
	{
		// Define local constants.

		String METHOD_NAME        = "formatTextString";
		String NEW_LINE           = "\n";
		String invalidColumnWidth = "Invalid column width : " + columnWidth;

		int    MIN_STRING_LENGTH  = 2;

		char   SPACE              = ' ';
		char   SEPARATOR          = ':';

		// Check the parameters received and throw the appropriate exception
		// if necessary.

		if (inputString == null)
		{
			throw new NullPointerException(buildErrorMessage(CLASS_NAME,
			                                                 METHOD_NAME,
			                                                 NULL_PARAMETER_MSG));
		}

		if (inputString.length() == 0)
		{
			throw new IllegalArgumentException(buildErrorMessage(CLASS_NAME,
			                                                     METHOD_NAME,
			                                                     ZERO_LENGTH_PARAMETER_MSG));
		}

		if (columnWidth < MIN_STRING_LENGTH)
		{
			throw new IllegalArgumentException(buildErrorMessage(CLASS_NAME,
			                                                     METHOD_NAME,
			                                                     invalidColumnWidth));
		}

		// Create a buffer to store the formatted version of the input string.

		StringBuffer formattedTextString = new StringBuffer(inputString);

		// Set the length of the buffer to the specified column width. This will
		// truncate the input string automatically if its length exceeds the
		// column width.

		formattedTextString.setLength(columnWidth);

		// If the length of the input string is less than the column width,
		// append spaces to it until it reaches the desired length.

		for (int i = inputString.length();i < (columnWidth - 1);i++)
		{
			formattedTextString.setCharAt(i,SPACE);
		}

		// If the input string is a label, replace the next to last character
		// with a ":".

		if (isALabel)
		{
			formattedTextString.setCharAt(columnWidth - 2,SEPARATOR);
		}

		// Overwrite the last character in the string with a SPACE. This is to
		// provide separation between this string and any characters that are
		// added to the right of it.

		formattedTextString.setCharAt(columnWidth - 1,SPACE);

		// If the addNewLine is set, add a carriage return to the end of the
		// string.

		if (addNewLine)
		{
			formattedTextString.append(NEW_LINE);
		}

		// Return the completed string to calling program.

		return (formattedTextString.toString());
	}

	// Public access methods

	// toString - A method to display the value of the private data members of
	//            the current instance. The intent of this method is to provide
	//            text-based verification output for development and debugging.
	//            Each subclass includes a method with the same name and
	//            purpose. Since this is the top-level of the hierarchy, this
	//            version also includes a header.

	public String toString()
	{
		// Define local constants.

		String METHOD_LABEL = CLASS_NAME + TO_STRING_LABEL;

		String COUNTER_PKG_HEADER_ONE = "Counter package instance values:\n";
		String COUNTER_PKG_HEADER_TWO = "--------------------------------\n";

		// Create a buffer to store the string to be returned, initializing it
		// with the values that define the header (since this is the top level
		// of the class hierarchy).

		StringBuffer returnString = new StringBuffer(COUNTER_PKG_HEADER_ONE + 
		                                             COUNTER_PKG_HEADER_TWO);

		// Add the information describing the data stored in this class
		// instance.

		try
		{
			returnString.append(formatTextString(DESCRIPTION_LABEL,
			                                     FIRST_COLUMN_LABEL_WIDTH,
			                                     true,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		try
		{
			returnString.append(formatTextString(getDescription(),
			                                     SECOND_COLUMN_VALUE_WIDTH,
			                                     false,true));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		// Return the completed string to calling program.

		return (returnString.toString());
	}

	// getDescription - A method to return the value of the description member
	//                  variable to the calling program.

	public String getDescription()
	{
		return (description);
	}

	// The following abstract methods are defined in the subclasses of Unit.
	// This is necessary in order to allow different public class types derived
	// from Unit to be stored and accessed as the generic Unit type. It is also
	// necessary in order to access the public access methods of the entire 
	// hierarchy without casting to a specific class type.

	// Fighting.java

	abstract public String  getNationality();
	abstract public String  getIdentity();
	abstract public String  getUnitType();
	abstract public String  getFirepower();
	abstract public String  getNormalRange();
	abstract public String  getStatus();

	abstract public boolean restore(boolean isLeaderPresent,int modifier);
	abstract public boolean check(int modifier);

	// Mobile.java

	abstract public String  getMovement();
}
