// ************************************************************************** //
// Fighting.java - This class is a member of the Counters package, which      //
//                 contains the class definitions and implementations for     //
//                 objects used to represent the virtual playing pieces in    //
//                 jASL.                                                      //
//                                                                            //
//                 NOTE: This program is based on Advanced Squad Leader, a    //
//                       product of The Avalon Hill Game Company.             //
//                                                                            //
// Written By    : Craig R. Campbell  -  December 1998                        //
//                                                                            //
// $Header: /tmp/java/jasl.cvs/jasl/source/jasl/counters/Fighting.java,v 1.6 2001/12/08 07:02:32 craig Exp $
// ************************************************************************** //

package Counters;

// ************************************************************************** //
// Fighting class - This class is used to distinguish between units that have //
//                  dynamic characteristics (ie. movement, firing, etc). from //
//                  units that are used to modify a space on the "board"      //
//                  (ie. wire, foxholes, etc). Instances of this class may    //
//                  not be instantiated directly. It is strictly a parent     //
//                  class.                                                    //
// ************************************************************************** //

abstract class Fighting extends Unit
{
	// Public symbolic constants

	// These constants are used to define the minimum values for some of the
	// key attributes for all of the fighting units defined by the public
	// subclasses of Unit.

	public static final int MIN_FIREPOWER        = 0;
	public static final int MIN_MOVEMENT         = 0;
	public static final int MIN_RANGE            = 0;

	public static final int MIN_PORTAGE_VALUE    = 0;
	public static final int MAX_PORTAGE_VALUE    = 99;

	// These constants are used to define the range of valid modifier values
	// for a Leader. They are defined here so that they may be used in methods
	// that have a Leader modifier in the parameter list to confirm that it is
	// valid. This includes the constructor for creating a new Leader instance.

	public static final int MIN_LEADERSHIP_MODIFIER = -3;
	public static final int MAX_LEADERSHIP_MODIFIER =  3;

	// Private symbolic constants

	// This constant is used as part of the error messages (see below) that
	// that are generated when an exception is thrown.

	private static final String CLASS_NAME = "Fighting";

	// Private data members

	// This variable contains the nationality of the derived object of this
	// class (ie. "American" or "German"). It must match one of the values
	// found in the NATIONALITIES list (see Counter.java).

	private String nationality;

	// This variable contains a simple identifier for the counter, typically
	// a single alphanumeric character. It is also used to store the full name
	// for Leaders and Heroes.

	private String identity;

	// This variable is used to store the specific type of the counter. It is
	// intended for vehicles (Pz VIb, T-34/76, etc.) and weapons (FlaK 30, ATR,
	// etc.) for more precise identification. Infantry units will typically 
	// have the same value as Unit.description but this could also be used for
	// special infantry designations such as SS, Gurkha, Paratroopers, etc.
	// Examples of possible values are found in the UNIT_TYPES list (see
	// Unit.java). If a value from this list is specified, it will be checked
	// against the specified nationality and, in some cases, the description.

	private String unitType;

	// This variable contains the firepower value of the derived object of this
	// class (ie. "4" or "88LL").

	private String firepower;

	// This variable contains the normal range of the derived object of this
	// class (ie. "6").

	private int normalRange;

	// This variable contains the current status of the derived object of this
	// class. The labels for the status values are defined as protected symbolic
	// constants in the appropriate subclass. This value is used as a bit-field
	// with the status values corresponding to the individual bits.

	private int status;

	// This variable contains the level of portage points of a derived object
	// of this class (how much it costs to carry a unit of this type). If this
	// value is set to MAX_PORTAGE_VALUE, it cannot be carried by another unit.

	private int portageValue;

	// The following strings are used as messages for any exceptions that may be
	// generated by bad data being passed to the constructor.

	private static final String nullPointerError =
		buildErrorMessage(CLASS_NAME,CONSTRUCTOR,NULL_PARAMETER_MSG);
		
	private static final String zeroLengthArgumentError =
		buildErrorMessage(CLASS_NAME,CONSTRUCTOR,ZERO_LENGTH_PARAMETER_MSG);

	private static final String invalidArgumentError =
		buildErrorMessage(CLASS_NAME,CONSTRUCTOR,INVALID_PARAMETER_MSG);

	// Constructor

	// This constructor is used during the instantiation of classes derived from
	// Fighting. The parameters are passed up the chain from the object being
	// created.

	protected Fighting(String description,String nationality,String identity,
	                   String unitType,String firepower,int normalRange,
	                   int portageValue)
	{
		// Pass the first parameter to the superclass constructor. If any
		// exceptions are thrown, assume that they will be caught and handled by
		// the program creating the object.

		super(description);

		// Check the value of each remaining parameter and copy the value to
		// the local copy of the corresponding variable if an exception is not
		// found.

		// Nationality

		if (nationality == null)
		{
			throw new NullPointerException(nullPointerError);
		}

		if (nationality.length() == 0)
		{
			throw new IllegalArgumentException(zeroLengthArgumentError);
		}

		// Check the nationality parameter against the valid entries list and
		// set the local copy if it is valid.

		if (NATIONALITIES_VECTOR.contains(nationality))
		{
			this.nationality = nationality;
		}

		// Throw an exception if a match was not found.

		else
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                   nationality);
		}

		// Identity

		setIdentity(identity);

		// Unit Type

		if (unitType == null)
		{
			throw new NullPointerException(nullPointerError);
		}

		if (unitType.length() == 0)
		{
			throw new IllegalArgumentException(zeroLengthArgumentError);
		}

		if ((unitType.equals(PARATROOPS)) && (!(nationality.equals(AMERICAN))))
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                   nationality + AND_SEPARATOR +
			                                   unitType);
		}

		if (((unitType.equals(AIRBORNE))    || (unitType.equals(ANZAC))       ||
		     (unitType.equals(CANADIAN))    || (unitType.equals(FREE_FRENCH)) ||
		     (unitType.equals(FREE_POLISH)) || (unitType.equals(GUARDSMEN))   ||
		     (unitType.equals(GURKHA)))     && (!(nationality.equals(BRITISH))))
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                   nationality + AND_SEPARATOR +
			                                   unitType);
		}

		if ((unitType.equals(SISSI)) && (!(nationality.equals(FINNISH))))
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                  nationality + AND_SEPARATOR +
			                                  unitType);
		}

		if (((unitType.equals(SS)) || (unitType.equals(ENGINEERS))) &&
		    (!(nationality.equals(GERMAN))))
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                   nationality + AND_SEPARATOR +
			                                   unitType);
		}

		if (((unitType.equals(COMMISSAR)) || (unitType.equals(GUARDS))) &&
		    (!(nationality.equals(RUSSIAN))))
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                   nationality + AND_SEPARATOR +
			                                   unitType);
		}

		if ((unitType.equals(COMMISSAR)) && (!(description.equals(LEADER))))
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                   description +
			                                   AND_SEPARATOR + unitType);
		}

		this.unitType = unitType;

		// Firepower

		if (firepower == null)
		{
			throw new NullPointerException(nullPointerError);
		}

		if (firepower.length() == 0)
		{
			throw new IllegalArgumentException(zeroLengthArgumentError);
		}

		this.firepower = firepower;

		// Normal Range

		if (normalRange < MIN_RANGE)
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                   normalRange);
		}

		this.normalRange = normalRange;

		// Portage Value

		if ((portageValue < MIN_PORTAGE_VALUE) ||
		    (portageValue > MAX_PORTAGE_VALUE))  
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                   portageValue);
		}

		this.portageValue = portageValue;

		// Set the initial status to the default. This value will be set more
		// specifically by a subclass constructor or the calling program through
		// the use of the setStatus() method.

		this.status = DEFAULT_INT_VALUE; 
	}

	// Public access methods

	// toString - A method to display the value of the private data members of
	//            the current instance. The intent of this method is to provide
	//            text-based verification output for development and debugging.
	//            Each subclass includes a method with the same name and
	//            purpose.

	public String toString()
	{
		// Define local constants.

		String METHOD_LABEL = CLASS_NAME + TO_STRING_LABEL;

		// Create a buffer to store the string to be returned, initializing it
		// with the string defined in the parent class version of this method.

		StringBuffer returnString = new StringBuffer(super.toString());

		// Add the information describing the data stored in this class
		// instance.

		// Nationality

		try
		{
			returnString.append(formatTextString(NATIONALITY_LABEL,
			                                     FIRST_COLUMN_LABEL_WIDTH,
			                                     true,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		try
		{
			returnString.append(formatTextString(getNationality(),
			                                     SECOND_COLUMN_VALUE_WIDTH,
			                                     false,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		// Identity

		try
		{
			returnString.append(formatTextString(IDENTITY_LABEL,
			                                     THIRD_COLUMN_LABEL_WIDTH,
			                                     true,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		try
		{
			returnString.append(formatTextString(getIdentity(),
			                                     FOURTH_COLUMN_VALUE_WIDTH,
			                                     false,true));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		// Unit Type

		try
		{
			returnString.append(formatTextString(UNIT_TYPE_LABEL,
			                                     FIRST_COLUMN_LABEL_WIDTH,
			                                     true,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		try
		{
			returnString.append(formatTextString(getUnitType(),
			                                     SECOND_COLUMN_VALUE_WIDTH,
			                                     false,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		// Firepower

		try
		{
			returnString.append(formatTextString(FIREPOWER_LABEL,
			                                     THIRD_COLUMN_LABEL_WIDTH,
			                                     true,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		try
		{
			returnString.append(formatTextString(getFirepower(),
			                                     FOURTH_COLUMN_VALUE_WIDTH,
			                                     false,true));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		// Normal Range

		try
		{
			returnString.append(formatTextString(NORMAL_RANGE_LABEL,
			                                     FIRST_COLUMN_LABEL_WIDTH,
			                                     true,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		try
		{
			returnString.append(formatTextString(getNormalRange(),
			                                     SECOND_COLUMN_VALUE_WIDTH,
			                                     false,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		// Portage Value

		try
		{
			returnString.append(formatTextString(PORTAGE_VALUE_LABEL,
			                                     THIRD_COLUMN_LABEL_WIDTH,
			                                     true,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		try
		{
			returnString.append(formatTextString(getPortageValue(),
			                                     FOURTH_COLUMN_VALUE_WIDTH,
			                                     false,true));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		// Status

		try
		{
			returnString.append(formatTextString(STATUS_LABEL,
			                                     FIRST_COLUMN_LABEL_WIDTH,
			                                     true,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		try
		{
			returnString.append(formatTextString(getStatus(),
			                                     80 - FIRST_COLUMN_LABEL_WIDTH,
			                                     false,true));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		// Return the completed string to calling program.

		return (returnString.toString());
	}

	// getNationality - A method to return the value of the nationality member
	//                  variable to the calling program.

	public String getNationality()
	{
		return (nationality);
	}

	// getIdentity - A method to return the value of the identity member
	//               variable to the calling program.

	public String getIdentity()
	{
		return (identity);
	}

	// getUnitType - A method to return the value of the unitType member
	//               variable to the calling program.

	public String getUnitType()
	{
		return (unitType);
	}

	// getFirepower - A method to return the value of the firepower member
	//                variable to the calling program.

	public String getFirepower()
	{
		return (firepower);
	}

	// getNormalRange - A method to return the value of the normalRange member
	//                  variable to the calling program.

	public String getNormalRange()
	{
		return (Integer.toString(normalRange));
	}

	// getPortageValue - A method to return the value of the portageValue member
	//                   variable to the calling program.

	public String getPortageValue()
	{
		return (Integer.toString(portageValue));
	}

	// The following methods will be overridden by subclass versions.

	// getStatus - A method to return the value of the status member variable
	//             to the calling program. Note that in the subclass definitions
	//             of this method, the integer value will be translated into the
	//             appropriate string value(s) by using a set of mask values
	//             defined for that subclass type (infantry, vehicles, support
	//             weapons, etc.).

	public String getStatus()
	{
		return (DEFAULT_STRING_VALUE);
	}

	// restore - A method to attempt to restore or change the status of a Unit.
	//           For example, a leader can attempt to rally a broken squad.
	//           The boolean value returned is used to indicate to the calling
	//           that the status of the Unit has changed.

	public boolean restore(boolean isLeaderPresent,int modifier)
	{
		return (DEFAULT_FLAG_VALUE);
	}

	// check - A method to test how well a Unit responds to a particular action.
	//         For example, a squad may be forced to take a morale check as the
	//         result of an attack. The boolean value returned is used to
	//         indicate to the calling that the status of the Unit has changed.

	public boolean check(int modifier)
	{
		return (DEFAULT_FLAG_VALUE);
	}

	// Public update methods

	// setIdentity - A method to change the current value of the identity
	//               member variable to the specified value.

	public void setIdentity(String newIdentity)
	{
		// Define local constants.

		String METHOD_NAME = "setIdentity";

		// Check the parameters received and throw the appropriate exception
		// if necessary.

		if (newIdentity == null)
		{
			throw new NullPointerException(buildErrorMessage(CLASS_NAME,
			                                                 METHOD_NAME,
			                                                 NULL_PARAMETER_MSG));
		}

		if (newIdentity.length() == 0)
		{
			throw new IllegalArgumentException(buildErrorMessage(CLASS_NAME,
			                                                     METHOD_NAME,
			                                                     ZERO_LENGTH_PARAMETER_MSG));
		}

		identity = newIdentity;
	}

	// setStatus - A method to set the value of the status member variable.
	//             More extensive and specific and checking will be performed
	//             in the subclass versions of this method. It is assumed that
	//             the value of the parameter will be used to set or unset a
	//             specific bit in the status value.

	public void setStatus(int newStatus)
	{
		if (newStatus >= DEFAULT_INT_VALUE)
		{
			status = newStatus;
		}
	}
}
