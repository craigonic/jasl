// ************************************************************************** //
// Fighting.java - This class is a member of the <B>counters</B> package, which      //
//                 contains the class definitions and implementations for     //
//                 objects used to represent the virtual playing pieces in    //
//                 jASL.                                                      //
//                                                                            //
//                 NOTE: This program is based on Advanced Squad Leader,      //
//                       which was created by The Avalon Hill Game Company,   //
//                       and lives on at Multi-Man Publishing.                //
//                                                                            //
// Written By: Craig R. Campbell  -  December 1998                            //
// ************************************************************************** //

package jasl.counters;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.json.JSONException;
import org.json.JSONObject;

import jasl.utilities.JsonData;
import jasl.utilities.Messages;

/**
 * This class is used to define the basic characteristics of a combat unit
 * (nationality, status, etc). It is intended strictly as a superclass, not to
 * be instantiated directly.
 *
 * @version 7.0
 * @author Copyright (C) 1998-2017 Craig R. Campbell (craigonic@gmail.com)
 * @see <A HREF="../../../source/jasl/counters/Fighting.html">Source code</A>
 */

abstract class Fighting extends Unit implements Identity, Nationality,
                                                Status, UnitType
{
	// Symbolic constants

	// This constant is used as part of the error messages (see below) that
	// are generated when an exception is thrown.

	private static final String CLASS_NAME = Fighting.class.getSimpleName();

	// The following string is used as a message for any exceptions that may
	// be generated by bad data being passed to the constructor.

	private static final String nullPointerError =
		Messages.buildErrorMessage("Fighting",Messages.CONSTRUCTOR,
		                           Messages.NULL_PARAMETER_MSG);

	// Private data members

	// This variable contains the nationality of the derived object of this
	// class (e.g. "American" or "German").

	private Nationalities _nationality;

	// This variable is used to store the specific type of the counter. It
	// is intended for vehicles (Pz VIb, T-34/76, etc.) and weapons
	// (FlaK 30, ATR, etc.) for more precise identification. Infantry units
	// may have infantry designations such as SS, Gurkha, Paratroopers, etc.
	// Examples of possible values for are found in the
	// <A HREF="UnitType.html">UnitType.InfantryTypes</A> enum. If one of these values is specified, it
	// will be checked against the specified nationality and, in some cases,
	// the description.
	//
	// This item may be empty, but not null.

	private String _unitType;

	// This variable contains a simple identifier for the unit, typically a
	// single alphanumeric character. It is also used to store the full name
	// for <A HREF="Leader.html">Leader</A>s and Heroes.

	private String _identity = "";

	// This variable contains the current status of the derived object of
	// this class. The status values are defined in the <A HREF="Status.html">Status.States</A> enum.
	// This value is used as a bit-field with the state values corresponding
	// to the individual bits.

	private int _status;

	// Constructor

	// During the instantiation of derived concrete classes the arguments
	// are passed up the inheritance tree from the constructor of the object
	// type being created.

	protected Fighting(Descriptions description,Nationalities nationality,
	                   String unitType)
	{
		// Pass the first argument to the superclass constructor. If any
		// exceptions are thrown, assume that they will be caught and
		// handled by the program creating the object.

		super(description);

		// Copy the value of each remaining argument to the
		// corresponding variable if an exception is not found.

		// Nationality

		_nationality = nationality;

		// Unit Type

		if (null == unitType)
		{
			throw new NullPointerException(nullPointerError);
		}

		_unitType = unitType;

		// Set the initial status to the default. This value will be set
		// more specifically through the use of the setStatus() method.

		_status = States.NORMAL.value();
	}

	// Public access methods

	/**
	 * Display a plain text representation of an instance of this class.
	 * <P>
	 * All of the attributes, beginning with the top-level class (<B><A HREF="Unit.html">Unit</A></B>) and
	 * continuing down the hierarchy to this level, are appended to the
	 * returned string. Each value is preceded by a label defined in this
	 * class or the interface associated with the item. There are no more
	 * than two values, including labels, in each line of output.
	 *
	 * @return a multi-line tabular <CODE>String</CODE>, 80 characters wide.
	 */

	public String toText()
	{
		// Create a buffer to store the string to be returned,
		// initializing it with the string defined in the parent class
		// version of this method.

		StringBuffer returnString = new StringBuffer(super.toText());

		// Add the information describing the data stored in this class
		// instance.

		// Nationality

		returnString.append(Messages.formatTextString(NATIONALITY_LABEL,
		                                              FIRST_COLUMN_LABEL_WIDTH,
		                                              true,false));

		returnString.append(Messages.formatTextString(nationality().toString(),
		                                              SECOND_COLUMN_VALUE_WIDTH,
		                                              false,false));

		// Unit Type

		returnString.append(Messages.formatTextString(UNIT_TYPE_LABEL,
		                                              THIRD_COLUMN_LABEL_WIDTH,
		                                              true,false));

		returnString.append(Messages.formatTextString(unitType(),
		                                              FOURTH_COLUMN_VALUE_WIDTH,
		                                              false,true));

		// Identity

		returnString.append(Messages.formatTextString(IDENTITY_LABEL,
		                                              FIRST_COLUMN_LABEL_WIDTH,
		                                              true,false));

		returnString.append(Messages.formatTextString(identity(),
		                                              80 - FIRST_COLUMN_LABEL_WIDTH,
		                                              false,true));

		// Status

		returnString.append(Messages.formatTextString(STATUS_LABEL,
		                                              FIRST_COLUMN_LABEL_WIDTH,
		                                              true,false));

		returnString.append(Messages.formatTextString(status().toString(),
		                                              80 - FIRST_COLUMN_LABEL_WIDTH,
		                                              false,true));

		// Return the completed string to calling program.

		return returnString.toString();
	}

	/**
	 * Generate a JSON representation of an instance of this class.
	 * <P>
	 * All of the attributes, beginning with the top-level class (<B><A HREF="Unit.html">Unit</A></B>) and
	 * continuing down the hierarchy to this level, are appended to the
	 * returned string. Each value is preceded by a label (key) defined in
	 * this class or the interface associated with the item. Entries at each
	 * level are successively indented to provide hierarchical formatting of
	 * the output.
	 *
	 * @return a <CODE>String</CODE> containing the JSON data.
	 *
	 * @see #fromJSON
	 */

	public String toJSON()
	{
		// Create a buffer to store the string to be returned,
		// initializing it with the string defined in the parent class
		// version of this method.

		StringBuffer returnString = new StringBuffer(super.toJSON());

		// Add the information describing the data stored in this class
		// instance.

		String INDENT = "  ";

		returnString.append(INDENT +
		                    JsonOutput.buildJSONPair(NATIONALITY_LABEL,nationality().name()) +
		                    JSON_OBJECT_SEPARATOR);
		returnString.append(INDENT +
		                    JsonOutput.buildJSONPair(UNIT_TYPE_LABEL,unitType()) +
		                    JSON_OBJECT_SEPARATOR);
		returnString.append(INDENT +
		                    JsonOutput.buildJSONPair(IDENTITY_LABEL,identity()) +
		                    JSON_OBJECT_SEPARATOR);
		returnString.append(INDENT +
		                    JsonOutput.buildJSONPair(STATUS_LABEL,_status) +
		                    JSON_OBJECT_SEPARATOR);

		// Return the completed string to calling program.

		return returnString.toString();
	}

	/**
	 * Return the nationality of a unit.
	 * <P>
	 * Use the toString() method of the enum to retrieve the label
	 * associated with the value (e.g. "American" for AMERICAN). The name()
	 * method returns its text representation (e.g. "AMERICAN").
	 *
	 * @return a <CODE>Nationalities</CODE> value specifying the unit's nationality.
	 */

	public final Nationalities nationality()
	{
		return _nationality;
	}

	/**
	 * Return the formal / specific type of a unit.
	 * <P>
	 * This provides for more accurate identification and application of the
	 * attributes associated with specific unit types. For example, it may
	 * specify vehicle names (Pz VIb, T-34/76, etc.) as well as special
	 * infantry designations (Gurkha, Paratroopers, etc.).
	 *
	 * @return a <CODE>String</CODE> specifying the more precise description of the
	 * unit's nationality, type, or capability.
	 *
	 * @see UnitType.InfantryTypes
	 */

	public final String unitType()
	{
		return _unitType;
	}

	/**
	 * Return the identity of a unit.
	 * <P>
	 * This is typically a single alphanumeric character, but it may also be
	 * a full name (e.g. for leaders and heroes).
	 * <P>
	 * The default setting is an empty string.
	 *
	 * @return a <CODE>String</CODE> specifying the unit's identity.
	 *
	 * @see #setIdentity
	 */

	public final String identity()
	{
		return _identity;
	}

	/**
	 * Return the current status of a unit.
	 * <P>
	 * In cases, where states are related (e.g. one state is a prerequisite
	 * for the other), only the "worst" state will be included. For example,
	 * if an infantry Unit is broken, and becomes subject to desperation
	 * morale, only the latter will be included in the list.
	 *
	 * @return an <B>unmodifiable</B> <CODE>List</CODE> of States describing the unit status. If
	 * the current state is NORMAL, the returned list will be empty.
	 *
	 * @see #clearStatus
	 * @see #setStatus
	 */

	public final List<States> status()
	{
		ArrayList<States> statesList = new ArrayList<States>();

		for (States state : States.values())
		{
			if ((_status & state.value()) > 0)
			{
				if ((States.BROKEN == state) &&
				    ((_status & States.DESPERATE.value()) > 0))
				{
					continue;
				}

				statesList.add(state);
			}
		}

		return Collections.unmodifiableList(statesList);
	}

	// Update methods

	/**
	 * Update an instance of this class to reflect the settings within the
	 * specified JSON data.
	 * <P>
	 * The setting for each attribute, beginning with the top-level class
	 * (<B><A HREF="Unit.html">Unit</A></B>) and continuing down the hierarchy to this level, is either
	 * checked against the corresponding input value (the majority of cases)
	 * or updated with it.
	 *
	 * @param jsonData JSON formatted text <CODE>String</CODE>.
	 *
	 * @throws IllegalArgumentException in the case where non-matching or
	 * invalid data values are found within the text.
	 * @throws JSONException in the case where the text is not valid JSON or
	 * an expected "key" is not found.
	 *
	 * @see #toJSON
	 */

	public void fromJSON(String jsonData)
	{
		// Start by going up the (class) hierarchy. Checks for a null or
		// zero length argument will be made at the top level (Unit).

		super.fromJSON(jsonData);

		// Check the values specific to this class.

		String exceptionDetails = "";

		try
		{
			JSONObject jsonObject = new JSONObject(jsonData);

			Nationalities nationality =
				Nationalities.valueOf(jsonObject.getString(NATIONALITY_LABEL));

			if (nationality != _nationality)
			{
				exceptionDetails =
					JsonData.FROM_JSON_NON_MATCH_PREFIX +
					nationality.name() +
					JsonData.FROM_JSON_FOR_SEPARATOR +
					NATIONALITY_LABEL;
			}

			String unitType = jsonObject.getString(UNIT_TYPE_LABEL);

			if (!unitType.equals(_unitType))
			{
				exceptionDetails =
					JsonData.FROM_JSON_NON_MATCH_PREFIX +
					unitType +
					JsonData.FROM_JSON_FOR_SEPARATOR +
					UNIT_TYPE_LABEL;
			}

			String identity = jsonObject.getString(IDENTITY_LABEL);

			setIdentity(identity);

			int status = jsonObject.getInt(STATUS_LABEL);

			if (status < 0)
			{
				exceptionDetails =
					JsonData.FROM_JSON_NOT_VALID_PREFIX +
					status +
					JsonData.FROM_JSON_FOR_SEPARATOR +
					STATUS_LABEL;
			}

			else
			{
				_status = status;
			}

			if (!exceptionDetails.isEmpty())
			{
				throw new IllegalArgumentException(Messages.buildErrorMessage(CLASS_NAME,
				                                                              JsonData.FROM_JSON_METHOD_NAME,
				                                                              exceptionDetails));
			}
		}

		catch (IllegalArgumentException exception)
		{
			if (exceptionDetails.isEmpty())
			{
				exceptionDetails = exception.getMessage();
			}

			throw new IllegalArgumentException(Messages.buildErrorMessage(CLASS_NAME,
			                                                              JsonData.FROM_JSON_METHOD_NAME,
			                                                              exceptionDetails));
		}

		catch (JSONException exception)
		{
			throw new JSONException(Messages.buildErrorMessage(CLASS_NAME,
			                                                   JsonData.FROM_JSON_METHOD_NAME,
			                                                   exception.getMessage()));
		}
	}

	/**
	 * Set a new identity for a unit.
	 * <P>
	 * If a null or zero length argument is specified, the current setting
	 * will be cleared.
	 *
	 * @param newIdentity the new identity.
	 *
	 * @see #identity
	 */

	public final void setIdentity(String newIdentity)
	{
		_identity = ((null == newIdentity) || (newIdentity.isEmpty())) ?
		            "" : newIdentity;
	}

	/**
	 * Change the status of a unit.
	 *
	 * @param state the state to be cleared or removed.
	 *
	 * @return a <CODE>boolean</CODE> indicating if the status of the unit was changed as
	 * a result of calling this method.
	 *
	 * @see #status
	 */

	public final boolean clearStatus(States state)
	{
		if ((_status & state.value()) > 0)
		{
			if ((States.BROKEN == state) &&
			    ((_status & States.DESPERATE.value()) > 0))
			{
				return false;
			}

			_status &= ~state.value();
			return true;
		}

		return false;
	}

	/**
	 * Change the status of a unit.
	 *
	 * @param state the state to be set or applied.
	 *
	 * @return a <CODE>boolean</CODE> indicating if the status of the unit was changed as
	 * a result of calling this method.
	 *
	 * @see #status
	 */

	public final boolean setStatus(States state)
	{
		if (0 == (_status & state.value()))
		{
			_status ^= state.value();

			if (States.DESPERATE == state) setStatus(States.BROKEN);

			return true;
		}

		return false;
	}

	// Other methods

	/**
	 * Add the identity setting, in parentheses, to the specified buffer.
	 * <P>
	 * This method is intended for use by the toString() implementation in
	 * derived public classes. The StringBuffer is modified only if it is
	 * <B>not</B> null <B>and</B> an identity value has been set (i.e. it is not empty).
	 *
	 * @param stringBuffer the item that the identity is to be appended to.
	 */

	protected final void appendIdentity(StringBuffer stringBuffer)
	{
		if ((null != stringBuffer) && !_identity.isEmpty())
		{
			stringBuffer.append(" (" + _identity + ")");
		}
	}
}
