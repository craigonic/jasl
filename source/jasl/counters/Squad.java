// ************************************************************************** //
// Squad.java - This class is a member of the <B>counters</B> package, which         //
//              contains the class definitions and implementations for        //
//              objects used to represent the virtual playing pieces in jASL. //
//                                                                            //
//              NOTE: This program is based on Advanced Squad Leader, which   //
//                    was created by The Avalon Hill Game Company, and lives  //
//                    on at Multi-Man Publishing.                             //
//                                                                            //
// Written By: Craig R. Campbell  -  December 1998                            //
// ************************************************************************** //

package jasl.counters;

import org.json.JSONException;
import org.json.JSONObject;

import jasl.utilities.JsonData;
import jasl.utilities.Messages;

/**
 * This class is used to represent a Squad counter.
 *
 * @version 6.0
 * @author Copyright (C) 1998-2024 Craig R. Campbell (craigonic@gmail.com)
 * @see <A HREF="../../../source/jasl/counters/Squad.html">Source code</A>
 */

public final class Squad extends Personnel implements SprayingFire
{
	// Symbolic constants

	/**
	 * Provides a label indicating if a squad has assault fire capability :
	 * <B>Can Assault Fire ?</B>
	 */

	public static final String CAN_ASSAULT_FIRE_LABEL = "Can Assault Fire ?";

	/**
	 * Provides a label for a squad's smoke placement capability :
	 * <B>Smoke Placement Exponent</B>
	 */

	public static final String SMOKE_PLACEMENT_EXP_LABEL = "Smoke Placement Exponent";

	/** Minimum valid smoke placement exponent value : <B>0</B> */

	private static final int MIN_SMOKE_EXPONENT = 0;

	/** Maximum valid smoke placement exponent value : <B>3</B> */

	private static final int MAX_SMOKE_EXPONENT = 3;

	// This constant is used as part of the error messages (see below) that
	// are generated when an exception is thrown.

	private static final String CLASS_NAME = Squad.class.getSimpleName();

	// The following string is used as a message for any exceptions that may
	// be generated by bad data being passed to the constructor.

	private static final String invalidArgumentError =
		Messages.buildErrorMessage(CLASS_NAME,Messages.CONSTRUCTOR,
		                           Messages.INVALID_PARAMETER_MSG);

	// Private data members

	// This flag variable indicates whether or not the squad that this
	// object represents is capable of assault fire and movement. This is
	// indicated on the physical counter by an underscored firepower value.

	private boolean _canAssaultFire;

	// This flag variable indicates whether or not the squad that this
	// object represents is capable of spraying fire. This is indicated on
	// the physical counter by an underscored range value.

	private boolean _canSprayFire;

	// This variable is used to indicate if the squad that this object
	// represents is capable of placing smoke grenades and the chance of
	// success.

	private int _smokePlacementExponent;

	// Constructor

	/**
	 * Construct a new <CODE>Squad</CODE>.
	 *
	 * @param nationality the nationality of the squad. Example - <B><A HREF="Nationality.html#_GERMAN_">GERMAN</A></B>
	 * @param unitType a more specific nationality, type, or capability
	 * description for the squad. Example - <B><A HREF="Infantry.html#_ENGINEERS_">ENGINEERS</A></B>
	 * @param firepower the inherent firepower of the squad. Example - <B>8</B>
	 * @param normalRange the maximum range that the squad's inherent
	 * firepower can be used at full strength. Example - <B>3</B>
	 * @param morale the morale level of the squad in its unbroken state.
	 * Example - <B>8</B>
	 * @param brokenMorale the morale level of the squad when it is broken.
	 * Example - <B>9</B>
	 * @param canSelfRally indicates if the squad can rally without the
	 * presence of a <A HREF="Leader.html">Leader</A>. Example - <B>false</B>
	 * @param basicPointValue the point "value" of the squad for the
	 * purpose of determining battlefield integrity and for design your own
	 * (DYO) scenarios. Example - <B>15</B>
	 * @param hasMaximumELR indicates if the squad inherently has the
	 * maximum experience level rating. Example - <B>true</B>
	 * @param classification the quality of the squad. Example - <B><A HREF="Classification.html#_FIRST_LINE_">FIRST_LINE</A></B>
	 * @param canAssaultFire indicates if the squad can use assault
	 * fire and movement. Example - <B>false</B>
	 * @param canSprayFire indicates if the squad can engage targets in
	 * multiple locations in a single fire action. Example - <B>true</B>
	 * @param smokePlacementExponent a value used to indicate the inherent
	 * smoke generation ability of the squad. Example - <B>2</B>
	 *
	 * @throws IllegalArgumentException in the case of an invalid argument.
	 */

	public Squad(Nationalities nationality,InfantryTypes unitType,
	             int firepower,int normalRange,int morale,int brokenMorale,
	             boolean canSelfRally,int basicPointValue,
	             boolean hasMaximumELR,Classifications classification,
	             boolean canAssaultFire,boolean canSprayFire,
	             int smokePlacementExponent)
	{
		// Pass the first 10 arguments to the superclass constructor.
		// If any exceptions are thrown, assume that they will be caught
		// and handled by the program creating the object.

		super(Descriptions.SQUAD,nationality,unitType,firepower,
		      normalRange,morale,brokenMorale,canSelfRally,
		      basicPointValue,hasMaximumELR,classification);

		// Check the value of each remaining argument and copy the value
		// to the local copy of the corresponding variable if an
		// exception is not found.

		// Assault Fire Capability

		_canAssaultFire = canAssaultFire;

		// Spraying Fire Capability

		_canSprayFire = canSprayFire;

		// Smoke Placement Capability

		if ((smokePlacementExponent < MIN_SMOKE_EXPONENT) ||
		    (smokePlacementExponent > MAX_SMOKE_EXPONENT))
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                   smokePlacementExponent);
		}

		_smokePlacementExponent = smokePlacementExponent;
	}

	// Public access methods

	/**
	 * Display a plain text representation of an instance of this class.
	 * <P>
	 * All of the attributes, beginning with the top-level class (<B><A HREF="Unit.html">Unit</A></B>) and
	 * continuing down the hierarchy to this level, are appended to the
	 * returned string. Each value is preceded by a label defined in this
	 * class or the interface associated with the item. There are no more
	 * than two values, including labels, in each line of output.
	 *
	 * @return a multi-line tabular <CODE>String</CODE>, 80 characters wide.
	 */

	public String toText()
	{
		// Create a buffer to store the string to be returned,
		// initializing it with the string defined in the parent class
		// version of this method.

		StringBuffer returnString = new StringBuffer(super.toText());

		// Add the information describing the data stored in this class
		// instance.

		// Assault Fire Capability

		returnString.append(Messages.formatTextString(CAN_ASSAULT_FIRE_LABEL,
		                                              FIRST_COLUMN_LABEL_WIDTH,
		                                              true,false));

		returnString.append(Messages.formatTextString(Messages.getChoiceLabel(canAssaultFire()),
		                                              SECOND_COLUMN_VALUE_WIDTH,
		                                              false,false));

		// Spraying Fire Capability

		returnString.append(Messages.formatTextString(CAN_SPRAY_FIRE_LABEL,
		                                              THIRD_COLUMN_LABEL_WIDTH,
		                                              true,false));

		returnString.append(Messages.formatTextString(Messages.getChoiceLabel(canSprayFire()),
		                                              FOURTH_COLUMN_VALUE_WIDTH,
		                                              false,true));

		// Smoke Placement Capability

		returnString.append(Messages.formatTextString(SMOKE_PLACEMENT_EXP_LABEL,
		                                              FIRST_COLUMN_LABEL_WIDTH,
		                                              true,false));

		returnString.append(Messages.formatTextString(Integer.toString(smokePlacementExponent()),
		                                              SECOND_COLUMN_VALUE_WIDTH,
		                                              false,true));

		// Return the completed string to calling program.

		return returnString.toString();
	}

	/**
	 * Generate a JSON representation of an instance of this class.
	 * <P>
	 * All of the attributes, beginning with the top-level class (<B><A HREF="Unit.html">Unit</A></B>) and
	 * continuing down the hierarchy to this level, are appended to the
	 * returned string. Each value is preceded by a label (key) defined in
	 * this class or the interface associated with the item. Entries at each
	 * level are successively indented to provide hierarchical formatting of
	 * the output.
	 *
	 * @return a <CODE>String</CODE> containing the JSON data.
	 *
	 * @see #fromJSON
	 */

	public String toJSON()
	{
		// Create a buffer to store the string to be returned,
		// initializing it with the string defined in the parent class
		// version of this method.

		StringBuffer returnString = new StringBuffer(super.toJSON());

		// Add the information describing the data stored in this class
		// instance.

		String INDENT = "      ";

		returnString.append(INDENT +
		                    JsonOutput.buildJSONPair(CAN_ASSAULT_FIRE_LABEL,canAssaultFire()) +
		                    JSON_OBJECT_SEPARATOR);
		returnString.append(INDENT +
		                    JsonOutput.buildJSONPair(CAN_SPRAY_FIRE_LABEL,canSprayFire()) +
		                    JSON_OBJECT_SEPARATOR);
		returnString.append(INDENT +
		                    JsonOutput.buildJSONPair(SMOKE_PLACEMENT_EXP_LABEL,smokePlacementExponent()) +
		                    JSON_OBJECT_END);

		// Return the completed string to calling program.

		return returnString.toString();
	}

	/**
	 * Indicate if a squad has assault fire and movement capabilities.
	 * <P>
	 * This is indicated on the physical counter by an underscored firepower
	 * value.
	 *
	 * @return a <CODE>boolean</CODE> indicating if the squad has this capability.
	 */

	public boolean canAssaultFire()
	{
		return _canAssaultFire;
	}

	/**
	 * Indicate if a squad is capable of spraying fire (attacking two
	 * adjacent hexes with a single fire action).
	 * <P>
	 * This is indicated on the physical counter by an underscored range
	 * value.
	 *
	 * @return a <CODE>boolean</CODE> indicating if the squad has this capability.
	 */

	public boolean canSprayFire()
	{
		return _canSprayFire;
	}

	/**
	 * Return the smoke placement capability of a squad.
	 * <P>
	 * This is indicated on the physical counter as a superscript on the
	 * firepower value.
	 *
	 * @return an <CODE>int</CODE> specifying the Smoke Placement Exponent value.
	 */

	public int smokePlacementExponent()
	{
		return _smokePlacementExponent;
	}

	// Update methods

	/**
	 * Update an instance of this class to reflect the settings within the
	 * specified JSON data.
	 * <P>
	 * The setting for each attribute, beginning with the top-level class
	 * (<B><A HREF="Unit.html">Unit</A></B>) and continuing down the hierarchy to this level, is either
	 * checked against the corresponding input value (the majority of cases)
	 * or updated with it.
	 *
	 * @param jsonData JSON formatted text <CODE>String</CODE>.
	 *
	 * @throws IllegalArgumentException in the case where non-matching data
	 * values are found within the text.
	 * @throws JSONException in the case where the text is not valid JSON or
	 * an expected "key" is not found.
	 *
	 * @see #toJSON
	 */

	public void fromJSON(String jsonData)
	{
		// Start by going up the (class) hierarchy. Checks for a null or
		// zero length argument will be made at the top level (Unit).

		super.fromJSON(jsonData);

		// Check the values specific to this class.

		try
		{
			JSONObject jsonObject       = new JSONObject(jsonData);
			String     exceptionDetails = "";

			boolean canAssaultFire =
				jsonObject.getBoolean(CAN_ASSAULT_FIRE_LABEL);

			if (canAssaultFire != _canAssaultFire)
			{
				exceptionDetails =
					JsonData.FROM_JSON_NON_MATCH_PREFIX +
					Messages.getTruthLabel(canAssaultFire).toLowerCase() +
					JsonData.FROM_JSON_FOR_SEPARATOR +
					CAN_ASSAULT_FIRE_LABEL;
			}

			boolean canSprayFire =
				jsonObject.getBoolean(CAN_SPRAY_FIRE_LABEL);

			if (canSprayFire != _canSprayFire)
			{
				exceptionDetails =
					JsonData.FROM_JSON_NON_MATCH_PREFIX +
					Messages.getTruthLabel(canSprayFire).toLowerCase() +
					JsonData.FROM_JSON_FOR_SEPARATOR +
					CAN_SPRAY_FIRE_LABEL;
			}

			int smokePlacementExponent =
				jsonObject.getInt(SMOKE_PLACEMENT_EXP_LABEL);

			if (smokePlacementExponent != _smokePlacementExponent)
			{
				exceptionDetails =
					JsonData.FROM_JSON_NON_MATCH_PREFIX +
					smokePlacementExponent +
					JsonData.FROM_JSON_FOR_SEPARATOR +
					SMOKE_PLACEMENT_EXP_LABEL;
			}

			if (!exceptionDetails.isEmpty())
			{
				throw new IllegalArgumentException(Messages.buildErrorMessage(CLASS_NAME,
				                                                              JsonData.FROM_JSON_METHOD_NAME,
				                                                              exceptionDetails));
			}
		}

		catch (JSONException exception)
		{
			throw new JSONException(Messages.buildErrorMessage(CLASS_NAME,
			                                                   JsonData.FROM_JSON_METHOD_NAME,
			                                                   exception.getMessage()));
		}
	}
}
