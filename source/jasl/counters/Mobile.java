// ************************************************************************** //
// Mobile.java - This class is a member of the <B>counters</B> package, which        //
//               contains the class definitions and implementations for       //
//               objects used to represent the virtual playing pieces in      //
//               jASL.                                                        //
//                                                                            //
//               NOTE: This program is based on Advanced Squad Leader, which  //
//                     was created by The Avalon Hill Game Company, and lives //
//                     on at <A HREF="http://www.multimanpublishing.com/ASL/asl.php">MultimanPublishing.com</A>.                          //
//                                                                            //
// Written By  : Craig R. Campbell  -  December 1998                          //
//                                                                            //
// $Id: Mobile.java,v 1.13 2008/11/25 08:19:48 craig Exp $
// ************************************************************************** //

package jasl.counters;

/**
 * This class is used to define the characteristics of units that have the
 * ability to move on their own. This class is strictly a superclass and cannot
 * be instantiated directly.
 *
 * @version 1.13
 * @author Craig R. Campbell
 * @see <A HREF="../../../source/jasl/counters/Mobile.html">Source code</A>
 */

class Mobile extends Fighting
{
	// Public symbolic constants

	/**
	 * Provides a label for a unit's movement allowance : <B>Movement</B>
	 */

	public static final String MOVEMENT_LABEL = "Movement";

	/**
	 * Provides a label for a unit's portage level : <B>Portage Level</B>
	 */

	public static final String PORTAGE_LEVEL_LABEL = "Portage Level";

	/**
	 * Provides a label for a unit's portage capacity : <B>Portage Capacity</B>
	 */

	public static final String PORTAGE_CAPACITY_LABEL = "Portage Capacity";

	// Private symbolic constants

	/** Minimum valid portage capacity value : <B>0</B> */

	private static final int MIN_PORTAGE_CAPACITY = 0;

	/** Minimum valid portage level value : <B>0</B> */

	private static final int MIN_PORTAGE_LEVEL = 0;

	// This constant is used as part of the error messages (see below) that are
	// generated when an exception is thrown.

	private static final String CLASS_NAME = "Mobile";

	// Private data members

	// This variable contains the movement allowance of the derived object of
	// this class (ie. "4").

	private int movement;

	// This variable contains the maximum portage points that the derived object
	// of this class can carry without affecting the number of movement points
	// available to it.

	private int portageCapacity;

	// This variable contains the current number of portage points of equipment
	// that the derived object of this class is carrying.

	private int portageLevel;

	// The following string is used as a message for the exception that may be
	// generated by bad data being passed to the constructor.

	private static final String invalidArgumentError =
		buildErrorMessage(CLASS_NAME,CONSTRUCTOR,INVALID_PARAMETER_MSG);

	// Constructor

	// This constructor is used during the instantiation of classes derived from
	// Mobile. The parameters are passed up the chain from the object being
	// created.

	protected Mobile(Descriptions description,String nationality,String identity,
	                 String unitType,String firepower,int normalRange,
	                 int portageValue,boolean sprayFireCapable,int movement,
	                 int portageCapacity)
	{
		// Pass the first 8 parameters to the superclass constructor. If any
		// exceptions are thrown, assume that they will be caught and handled by
		// the program creating the object.

		super(description,nationality,identity,unitType,firepower,normalRange,
		      portageValue,sprayFireCapable);

		// Check the value of each remaining parameter and copy the value to
		// the local copy of the corresponding variable if an exception is not
		// found.

		// Movement

		if (movement < MIN_MOVEMENT)
		{
			throw new IllegalArgumentException(invalidArgumentError + movement);
		}

		this.movement = movement;

		// Portage Capacity

		if (portageCapacity < MIN_PORTAGE_CAPACITY)
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                   portageCapacity);
		}

		this.portageCapacity = portageCapacity;

		// Portage Level

		this.portageLevel = MIN_PORTAGE_LEVEL; // Assume that this value will
		                                       // be determined after the object
		                                       // is instantiated.
	}

	// Public access methods

	/**
	 * Display the value of each of the private data members that describe the
	 * current instance. All of the members, beginning with the top-level class
	 * (<B><A HREF="Unit.html">Unit</A></B>) and continuing down the hierarchy to this level, are appended to
	 * the returned string. Each value is preceded by a label defined in the
	 * <B><A HREF="Counter.html">Counter</A></B> interface. There are no more than two values, including labels,
	 * in each line of output.
	 *
	 * @return a multi-line tabular <CODE>String</CODE>, 80 characters wide.
	 */

	public String toString()
	{
		// Define local constants.

		String METHOD_LABEL = CLASS_NAME + TO_STRING_LABEL;

		// Create a buffer to store the string to be returned, initializing it
		// with the string defined in the parent class version of this method.

		StringBuffer returnString = new StringBuffer(super.toString());

		// Add the information describing the data stored in this class
		// instance.

		// Movement

		try
		{
			returnString.append(formatTextString(MOVEMENT_LABEL,
			                                     FIRST_COLUMN_LABEL_WIDTH,
			                                     true,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		try
		{
			returnString.append(formatTextString(getMovement(),
			                                     SECOND_COLUMN_VALUE_WIDTH,
			                                     false,true));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		// Portage Capacity

		try
		{
			returnString.append(formatTextString(PORTAGE_CAPACITY_LABEL,
			                                     FIRST_COLUMN_LABEL_WIDTH,
			                                     true,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		try
		{
			returnString.append(formatTextString(getPortageCapacity(),
			                                     SECOND_COLUMN_VALUE_WIDTH,
			                                     false,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		// Portage Level

		try
		{
			returnString.append(formatTextString(PORTAGE_LEVEL_LABEL,
			                                     THIRD_COLUMN_LABEL_WIDTH,
			                                     true,false));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		try
		{
			returnString.append(formatTextString(getPortageLevel(),
			                                     FOURTH_COLUMN_VALUE_WIDTH,
			                                     false,true));
		}

		catch (NullPointerException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		catch (IllegalArgumentException exception)
		{
			System.err.println(METHOD_LABEL + exception);
		}

		// Return the completed string to calling program.

		return (returnString.toString());
	}

	/**
	 * Determine the number of movement factors or points available to this
	 * unit before it begins to move. This value may be affected by the current
	 * portage level of the unit.
	 *
	 * @return a <CODE>String</CODE> specifying the movement capability in factors or points.
	 */

	public String getMovement()
	{
		return (Integer.toString(movement));
	}

	/**
	 * Determine the maximum number of portage points (PP) of personnel and/or
	 * equipment that this unit can carry without affecting the movement factors
	 * or points available to it.
	 *
	 * @return a <CODE>String</CODE> specifying the portage capacity.
	 */

	public String getPortageCapacity()
	{
		return (Integer.toString(portageCapacity));
	}

	/**
	 * Determine the number of portage points (PP) of personnel and/or equipment
	 * that this unit is currently carrying.
	 *
	 * @return a <CODE>String</CODE> specifying the current portage level.
	 */

	public String getPortageLevel()
	{
		return (Integer.toString(portageLevel));
	}
}
