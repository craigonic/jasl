// ************************************************************************** //
// Player.java - This class is a member of the <B>ui.data</B> package, which         //
//               contains the class definitions and implementations for       //
//               objects used to store and manage the state of an instance of //
//               jASL.                                                        //
//                                                                            //
//               NOTE: This program is based on Advanced Squad Leader, which  //
//                     was created by The Avalon Hill Player Company, and     //
//                     lives on at <A HREF="http://www.multimanpublishing.com/Products/tabid/58/CategoryID/4/Default.aspx">MultimanPublishing.com</A>.                    //
//                                                                            //
// Written By: Craig R. Campbell  -  February 2013                            //
// ************************************************************************** //

package jasl.ui.data;

import java.util.Collections;
import java.util.ArrayList;
import java.util.List;

import jasl.counters.Nationality;
import jasl.utilities.Messages;

/**
 * This class is used to provide data management for a player during a jASL
 * session. This includes the player's name, the nationality of the units that
 * he or she commands, and the turn that they enter the game, as well as the
 * ability to add, delete, and access the individual <A HREF="../../counters/Unit.html">Unit</A>s.
 *
 * @version 1.2
 * @author Copyright (C) 2013-2015 Craig R. Campbell (craigonic@gmail.com)
 * @see <A HREF="../../../../source/jasl/ui/data/Player.html">Source code</A>
 */

public final class Player
{
	// Private data members

	// This variable is used to store the player's name. It (obviously) may
	// not be null or empty.

	private String _name;

	// This variable contains the nationality of the units managed by the
	// player (e.g. "American" or "German").

	private Nationality.Nationalities _nationality;

	// This variable is used to store the turn number that the player (and
	// the units he or she manages) will enter the game. It must be greater
	// than zero and less than <B>TBD</B>.

	private int _entryTurn;

	// This variable is used to store the units managed by the player. The
	// list is updated using the addUnit() and deleteUnit() methods. The
	// labels associated with the units are available through unitList() and
	// unit() may be used to access individual <A HREF="../../counters/Unit.html">Unit</A> objects.

	private ArrayList<String> _unitList;

	// The following strings are used as messages for any exceptions that
	// may be generated by bad data being passed to the constructor.

	private static final String CLASS_NAME = "Player";

	private static final String nullPointerError =
		Messages.buildErrorMessage(CLASS_NAME,Messages.CONSTRUCTOR,
		                           Messages.NULL_PARAMETER_MSG);

	private static final String zeroLengthArgumentError =
		Messages.buildErrorMessage(CLASS_NAME,Messages.CONSTRUCTOR,
		                           Messages.ZERO_LENGTH_PARAMETER_MSG);

	private static final String invalidArgumentError =
		Messages.buildErrorMessage(CLASS_NAME,Messages.CONSTRUCTOR,
		                           Messages.INVALID_PARAMETER_MSG);

	// Constructor

	/**
	 * Construct a new <CODE>Player</CODE>.
	 *
	 * @param name the name of the player.
	 * @param nationality the nationality of the units managed by the
	 * player. Example - <B><A HREF="../../counters/Nationality.html#_GERMAN_">GERMAN</A></B>
	 * @param entryTurn the turn when the units managed by the player enter
	 * the game.
	 * Example - <B>1</B>
	 *
	 * @throws NullPointerException in the case of a null name argument.
	 * @throws IllegalArgumentException in the case of an empty name or an
	 * invalid (less than 1) entry turn argument.
	 */

	public Player(String name,Nationality.Nationalities nationality,
	              int entryTurn)
	{
		// Copy the value of each remaining parameter to the
		// corresponding variable if an exception is not found.

		// Name

		if (null == name)
		{
			throw new NullPointerException(nullPointerError);
		}

		if (0 == name.length())
		{
			throw new IllegalArgumentException(zeroLengthArgumentError);
		}

		_name = name;

		// Nationality

		_nationality = nationality;

		// Entry turn

		if (entryTurn < 1)
		{
			throw new IllegalArgumentException(invalidArgumentError +
			                                   entryTurn);
		}

		_entryTurn = entryTurn;

		_unitList = new ArrayList<String>();
	}

	// Public access methods

	/**
	 * Return the name of the player.
	 *
	 * @return a <CODE>String</CODE> specifying the player's name.
	 */

	public String toString()
	{
		return _name;
	}

	/**
	 * Return a text representation of the attributes of the player.
	 *
	 * The output includes the labels associated with the units managed by
	 * the player.
	 *
	 * @return a multi-line <CODE>String</CODE> specifying the current
	 * settings of an instance of this type.
	 *
	 * @see #unitList
	 */

	public String toText()
	{
		StringBuffer returnString = new StringBuffer();

		returnString.append("Player:\t" + toString() + "\n\n");
		returnString.append("\tNationality:\t" + nationality() + "\n");
		returnString.append("\tEntry Turn :\t" +
		                     Integer.toString(_entryTurn) + "\n");

		returnString.append("\n\tUnits:\n");

		for (String unit : unitList())
		{
			returnString.append("\t\t" + unit + "\n");
		}

		// Return the completed string to calling program.

		return returnString.toString();
	}

	/**
	 * Return the nationality of the units managed by the player.
	 *
	 * @return a <CODE>String</CODE> specifying the nationality of the player's units.
	 */

	public String nationality()
	{
		return _nationality.toString();
	}

	/**
	 * Return the turn that the units managed by the player will enter the
	 * game.
	 *
	 * @return an <CODE>int</CODE> specifying the entry turn of the player's units.
	 */

	public int entryTurn()
	{
		return _entryTurn;
	}

	/**
	 * Return one of the units managed by the player.
	 *
	 * Units that are being managed by the one specified (i.e. portaged)
	 * will be included (i.e. accessible from the returned object).
	 *
	 * @param index the (zero-based) index of the <A HREF="../../counters/Unit.html">Unit</A> to be accessed
	 *
	 * @return the <CODE>Unit</CODE> at the specified index.
	 *
	 * @throws IndexOutOfBoundsException in the case where index is less than
	 * zero or greater than the number of units in the list.
	 *
	 * @see #unitList
	 */

	public String unit(int index)
	{
		String unitToBeReturned;

		try
		{
			unitToBeReturned = _unitList.get(index);
		}

		catch (IndexOutOfBoundsException exception)
		{
			throw new IndexOutOfBoundsException(Messages.buildErrorMessage(CLASS_NAME,
			                                                               "unit",
			                                                               Messages.INVALID_PARAMETER_MSG + index));
		}

		return unitToBeReturned;
	}

	/**
	 * Return a list of descriptions of the units managed by the player.
	 *
	 * Units that are being managed by another (i.e. portaged) will <B>not</B>
	 * appear in the list. A '+' will be appended to the label associated
	 * with the unit responsible for them.
	 *
	 * @return a <CODE>List</CODE> of String items specifying the labels associated with
	 * the player's units.
	 */

	public List<String> unitList()
	{
		return Collections.unmodifiableList(_unitList);
	}

	// Public update methods

	/**
	 * Place a new unit under the player's command.
	 *
	 * @param unit the <A HREF="../../counters/Unit.html">Unit</A> to be added
	 *
	 * @throws NullPointerException in the case of a null object.
	 * @throws IllegalArgumentException in the case where the unit's
	 * nationality does not match the one associated with the player.
	 */

	public void addUnit(String unit)
	{
		if (null == unit)
		{
			throw new NullPointerException(Messages.buildErrorMessage(CLASS_NAME,
			                                                          "addUnit",
			                                                          Messages.NULL_PARAMETER_MSG));
		}
/*
		if (0 != nationality().compareTo(unit.nationality()))
		{
			throw new IllegalArgumentException(Messages.buildErrorMessage(CLASS_NAME,
			                                                              "addUnit",
			                                                              "Incompatible unit and player nationality."));
		}
*/
		_unitList.add(unit);
	}

	/**
	 * Remove a unit under the player's command.
	 *
	 * If the unit to be removed is currently managing (i.e. portaging)
	 * other Units (e.g. support weapons), those items will be placed back
	 * into the general list after the specified unit is deleted.
	 *
	 * @param index the (zero-based) index of the <A HREF="../../counters/Unit.html">Unit</A> to be removed
	 *
	 * @throws IndexOutOfBoundsException in the case where index is less than
	 * zero or greater than the number of units in the list.
	 */

	public void deleteUnit(int index)
	{
		String unitToBeDeleted;

		try
		{
			unitToBeDeleted = _unitList.get(index);
		}

		catch (IndexOutOfBoundsException exception)
		{
			throw new IndexOutOfBoundsException(Messages.buildErrorMessage(CLASS_NAME,
			                                                               "deleteUnit",
			                                                               Messages.INVALID_PARAMETER_MSG + index));
		}

		// Place any Unit objects that are be managed (e.g. support
		// weapons that are being portaged) by the unit to be removed in
		// a separate, temporary list. Once the specified unit has been
		// deleted, add the items formerly under its control to the main
		// list.

		_unitList.remove(index);
	}
}
