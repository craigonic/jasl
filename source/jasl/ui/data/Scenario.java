// ************************************************************************** //
// Scenario.java - This class is a member of the <B>ui.data</B> package, which       //
//                 contains the class definitions and implementations for     //
//                 objects used to store and manage the state of an instance  //
//                 of jASL.                                                   //
//                                                                            //
//                 NOTE: This program is based on Advanced Squad Leader,      //
//                       which was created by The Avalon Hill Game Company,   //
//                       and lives on at <A HREF="http://www.multimanpublishing.com/Products/tabid/58/CategoryID/4/Default.aspx">MultimanPublishing.com</A>.              //
//                                                                            //
// Written By: Craig R. Campbell  -  January 2016                             //
// ************************************************************************** //

package jasl.ui.data;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.ArrayList;

import org.json.JSONArray;
import org.json.JSONObject;

import jasl.counters.ExperienceLevelRating;
import jasl.counters.Unit;
import jasl.utilities.Messages;

/**
 * This singleton class is used to translate text data in the JSON format into
 * the objects and settings necessary to play a jASL scenario.
 *
 * @version 2.1
 * @author Copyright (C) 2016-2018 Craig R. Campbell (craigonic@gmail.com)
 * @see <A HREF="../../../../source/jasl/ui/data/Scenario.html">Source code</A>
 */

public final class Scenario
{
	// The following items are set using values associated with (mostly?)
	// matching key names in the JSON input file.

	// The name of the scenario.

	private String _name;

	// The starting side in the scenario.

	private Side.Sides _startingSide = Side.Sides.ALLIES;

	// The one and only Scenario object. This item is created (if an
	// instance does not already exist) and accessed via the scenario()
	// method. The data within it can be set or replaced using one of the
	// load() methods.

	private static Scenario _scenario = null;

	// The following strings correspond to some of the "keys" used in the
	// JSON input data. The other keys are labels defined within the
	// counters package, see the toJSON() methods there for examples.

	private static final String NAME             = "name";
	private static final String STARTING_SIDE    = "starting side";
	private static final String SIDES_ARRAY      = "sides";
	private static final String SIDE             = "side";
	private static final String TURNS            = "turns";
	private static final String SETS_UP_FIRST    = "sets up first";
	private static final String FORMATIONS_ARRAY = "formations";
	private static final String ENTRY_TURN       = "entry turn";
	private static final String UNITS_ARRAY      = "units";
	private static final String COPIES           = "copies";

	// The following strings are used as messages for any exceptions that
	// may be generated by bad data being passed one of the load methods.

	private static final String CLASS_NAME = Scenario.class.getSimpleName();
	private static final String LOAD_METHOD_NAME = "load";

	private static final String nullPointerError =
		Messages.buildErrorMessage(CLASS_NAME,LOAD_METHOD_NAME,
		                           Messages.NULL_PARAMETER_MSG);
	/**
	 * Create the Scenario instance or provide access its data.
	 * <P>
	 * If it does not exist, a new (empty) object is instantiated. The
	 * load() methods are provided to create or replace the data set managed
	 * by it.
	 *
	 * @return a reference to the new or existing <CODE>Scenario</CODE>.
	 */

	public static Scenario scenario()
	{
		if (null == _scenario) _scenario = new Scenario();

		return _scenario;
	}

	// Public access methods

	/**
	 * Load a new <CODE>Scenario</CODE>.
	 * <P>
	 * This method processes the specified JSON input data, using it to
	 * generate the objects and settings that define a scenario. The input
	 * stream will be closed when all of the data has been read.
	 *
	 * @param inputStream the UTF-8 encoded JSON input data.
	 *
	 * @throws NullPointerException in the case of a null InputStream
	 * argument.
	 * @throws IOException in the case where an error occurs while reading
	 * the input data stream.
	 * @throws Exception in the case where an error occurs while parsing the
	 * JSON data. This may be a JSONException or an
	 * IllegalArgumentException.
	 */

	public void load(InputStream inputStream) throws IOException
	{
		if (null == inputStream)
		{
			throw new NullPointerException(nullPointerError);
		}

		try
		{
			processInputStream(inputStream);
		}

		catch (IOException exception)
		{
			throw exception;
		}
	}

	/**
	 * Load a new <CODE>Scenario</CODE>.
	 * <P>
	 * This method performs the same function as the one that accepts an
	 * InputStream argument, with the added functionality of retrieving the
	 * data from the specified file.
	 *
	 * @param filename the name of the file containing the UTF-8
	 * encoded JSON input data.
	 *
	 * @throws NullPointerException in the case of a null filename argument.
	 * @throws FileNotFoundException in the case where the file does not
	 * exist or cannot be read.
	 * @throws IOException in the case where an error occurs while reading
	 * the file.
	 * @throws Exception in the case where an error occurs while parsing the
	 * JSON data. This may be a JSONException or an
	 * IllegalArgumentException.
	 */

	public void load(String filename) throws IOException
	{
		if (null == filename)
		{
			throw new NullPointerException(nullPointerError);
		}

		try
		{
			processInputStream(new FileInputStream(filename));
		}

		catch (IOException exception)
		{
			throw exception;
		}
	}

	// This load() method is intended primarily for testing.

	/**
	 * Load a new <CODE>Scenario</CODE>.
	 * <P>
	 * This method processes the specified JSON input data, using it to
	 * generate the objects and settings that define a scenario.
	 *
	 * @param jsonData the UTF-8 encoded JSON input data.
	 *
	 * @throws NullPointerException in the case of a null argument.
	 * @throws Exception in the case where an error occurs while parsing the
	 * JSON data. This may be a JSONException or an
	 * IllegalArgumentException.
	 */

	public void load(StringBuffer jsonData)
	{
		if (null == jsonData)
		{
			throw new NullPointerException(nullPointerError);
		}

		parseJsonData(jsonData.toString());
	}

	/**
	 * Return a text representation of the attributes of a scenario.
	 *
	 * @return a multi-line <CODE>String</CODE> specifying an overview of the elements of
	 * the scenario.
	 */

	public String toText()
	{
		StringBuffer returnString = new StringBuffer();

		returnString.append("Name:\t");
		returnString.append(toString());
		returnString.append("\n");

		returnString.append("Starting side:\t");
		returnString.append(startingSide().toString());
		returnString.append("\n");

		// Return the completed string to calling program.

		return returnString.toString();
	}

	/**
	 * Return the name of a scenario.
	 *
	 * @return a <CODE>String</CODE> specifying the scenario name.
	 */

	public String toString()
	{
		return _name;
	}

	/**
	 * Return the starting side in a scenario.
	 *
	 * @return a <CODE>Side.Sides</CODE> specifying the starting side in the scenario.
	 */

	public Side.Sides startingSide()
	{
		return _startingSide;
	}

	// Constructor

	private Scenario() {}

	// Private helper methods

	/**
	 * Translate the input data stream into a text string, which is
	 * subsequently parsed.
	 * <P>
	 * This method is called from the constructors and does just what its
	 * name implies. When the read operation is complete, the input stream
	 * is closed and the String is passed to the parseJsonData() method.
	 *
	 * @param inputStream the UTF-8 encoded JSON input data.
	 */

	private void processInputStream(InputStream inputStream) throws IOException
	{
		StringBuilder stringBuilder = new StringBuilder(2048);

		try
		{
			BufferedReader bufferedReader =
				new BufferedReader(new InputStreamReader(inputStream,
				                                         "UTF-8"));
			String inputString;

			while (null != (inputString = bufferedReader.readLine()))
			{
				stringBuilder.append(inputString);
			}

			inputStream.close();
		}

		catch (IOException exception)
		{
			throw exception;
		}

//		System.out.println("Input data:\n" + stringBuilder.toString());

		parseJsonData(stringBuilder.toString());
	}

	/**
	 * Parse the specified JSON data and use it to generate the objects and
	 * settings that define the scenario.
	 * <P>
	 * This method is called from processInputStream() or the load() method
	 * that accepts a StringBuffer argument.
	 *
	 * @param jsonData the JSON data to be parsed.
	 */

	private void parseJsonData(String jsonData)
	{
		try
		{
			// TODO: Validate JSON data using schema?

			JSONObject jsonObject = new JSONObject(jsonData);

			_name = jsonObject.getString(NAME);

			if (_name.isEmpty())
			{
				throw new IllegalArgumentException("Scenario name is empty.");
			}

			_startingSide =
				Side.Sides.valueOf(jsonObject.getString(STARTING_SIDE));

			JSONArray jsonArray =
				jsonObject.getJSONArray(SIDES_ARRAY);

			for (int i = 0;i < jsonArray.length();++i)
			{
				parseSideData(jsonArray.getJSONObject(i));
			}
		}

		catch (IllegalArgumentException exception)
		{
			throw new IllegalArgumentException(Messages.buildErrorMessage(CLASS_NAME,
			                                                              LOAD_METHOD_NAME,
			                                                              exception.getMessage()));
		}

		catch (org.json.JSONException exception)
		{
			throw new org.json.JSONException(Messages.buildErrorMessage(CLASS_NAME,
			                                                            LOAD_METHOD_NAME,
			                                                            exception.getMessage()));
		}
	}

	/**
	 * Parse the specified JSON data and use it to generate the objects and
	 * settings that define one side in a scenario.
	 * <P>
	 * This method is called from parseJsonData(). The input data is used to
	 * populate a Scenario.OrderOfBattle object for the side.
	 *
	 * @param jsonObject the JSON data to be parsed.
	 */

	private void parseSideData(JSONObject jsonObject)
	{
		Side.Sides side =
			Side.Sides.valueOf(jsonObject.getString(SIDE));

		int experienceLevelRating = 0;

		if (jsonObject.has(ExperienceLevelRating.ELR_LABEL))
		{
			experienceLevelRating =
				jsonObject.getInt(ExperienceLevelRating.ELR_LABEL);

			if ((experienceLevelRating < ExperienceLevelRating.MIN_ELR) ||
			    (experienceLevelRating > ExperienceLevelRating.MAX_ELR))
			{
				throw new IllegalArgumentException(Messages.INVALID_PARAMETER_MSG +
				                                   ExperienceLevelRating.ELR_LABEL +
				                                   " (" + experienceLevelRating + ") < " +
				                                   ExperienceLevelRating.MIN_ELR +
				                                   " or > " + ExperienceLevelRating.MAX_ELR);
			}
		}

		int sniperActivationNumber = 0;

		if (jsonObject.has(SniperActivationNumber.SAN_LABEL))
		{
			sniperActivationNumber =
				jsonObject.getInt(SniperActivationNumber.SAN_LABEL);

			if ((sniperActivationNumber < SniperActivationNumber.MIN_SAN) ||
			    (sniperActivationNumber > SniperActivationNumber.MAX_SAN) ||
			    (1 == sniperActivationNumber))
			{
				throw new IllegalArgumentException(Messages.INVALID_PARAMETER_MSG +
				                                   SniperActivationNumber.SAN_LABEL +
				                                   " (" + sniperActivationNumber + ") < " +
				                                   SniperActivationNumber.MIN_SAN +
				                                   ", 1, or > " + SniperActivationNumber.MAX_SAN);
			}
		}

		int turns = jsonObject.getInt(TURNS);

		if (turns < 0)
		{
			throw new IllegalArgumentException(Messages.INVALID_PARAMETER_MSG +
			                                   TURNS + " (" + turns + ") < 0");
		}

		boolean setsUpFirst = false;

		if (jsonObject.has(SETS_UP_FIRST))
		{
			setsUpFirst = jsonObject.getBoolean(SETS_UP_FIRST);
		}

		OrderOfBattle orderOfBattle =
			new OrderOfBattle(side,experienceLevelRating,
			                  sniperActivationNumber,turns,
			                  setsUpFirst);
		JSONArray jsonArray =
			jsonObject.getJSONArray(FORMATIONS_ARRAY);

		for (int i = 0;i < jsonArray.length();++i)
		{
			parseFormationData(jsonArray.getJSONObject(i),
			                   turns,experienceLevelRating);
		}
	}

	/**
	 * Parse the specified JSON data and use it to generate the objects and
	 * settings associated with a formation (one or more groups of Units) on
	 * one side in a scenario.
	 * <P>
	 * This method is called from parseSideData(). The input data is used to
	 * populate a Scenario.Formation object, which is returned to the
	 * caller.
	 * Map<Integer,List<Formation>> formationMap =
	 *     new LinkedHashMap<Integer,List<Formation>();
	 *
	 * @param jsonObject the JSON data to be parsed.
	 * @param turns the number of turns allotted to the side that the
	 * formation is associated with.
	 * @param elr the experience level rating (ELR) of the (infantry)
	 * Units within the formation.
	 */

	private void parseFormationData(JSONObject jsonObject,int turns,int elr)
	{
		String name = jsonObject.getString(NAME);

		if (name.isEmpty())
		{
			throw new IllegalArgumentException("Formation name is empty.");
		}

		int entryTurn = 0;

		// If an entry turn is specified, verify that it falls within
		// the range defined by the scenario. If it is NOT set, this
		// indicates that the Units must be positioned before game play
		// begins.

		if (jsonObject.has(ENTRY_TURN))
		{
			entryTurn = jsonObject.getInt(ENTRY_TURN);

			if ((entryTurn < 0) || (entryTurn > turns))
			{
				throw new IllegalArgumentException(Messages.INVALID_PARAMETER_MSG +
				                                   ENTRY_TURN + " (" + entryTurn +
				                                   ") < 0 or > " + turns);
			}
		}

		Formation formation = new Formation(name,entryTurn);

		JSONArray jsonArray = jsonObject.getJSONArray(UNITS_ARRAY);

		for (int i = 0;i < jsonArray.length();++i)
		{
			parseUnitData(jsonArray.getJSONObject(i),elr);
		}
	}

	/**
	 * Parse the specified JSON data and use it to generate the Unit objects
	 * associated with a formation.
	 * <P>
	 * This method is called from parseFormationData(). The input data is
	 * used to generate a list of Unit objects, which is returned to the
	 * caller.
	 *
	 * @param jsonObject the JSON data to be parsed.
	 * @param elr the experience level rating (ELR) of the (infantry)
	 * Units.
	 */

	private void parseUnitData(JSONObject jsonObject,int elr)
	{
		int copies = 1;

		if (jsonObject.has(COPIES))
		{
			copies = jsonObject.getInt(COPIES);

			if (copies < 1)
			{
				throw new IllegalArgumentException(Messages.INVALID_PARAMETER_MSG +
				                                   COPIES + " (" + copies + ") < 1");
			}
		}

		ArrayList<Unit> unitList = new ArrayList<Unit>();

		for (int i = 0;i < copies;++i)
		{
			Unit unit =
				Unit.factory(jsonObject.toString(),elr);

//			System.out.println(unit.toString());

			unitList.add(unit);
		}
	}

	/**
	 */

	private class OrderOfBattle
	{
		// The following items are set by corresponding arguments passed
		// to the constructor.

		// The side represented by the Units in an instance of this
		// class.

		public Side.Sides side = Side.Sides.ALLIES;

		// Their experience level rating (ELR).

		public int experienceLevelRating;

		// The sniper activation number (SAN).

		public int sniperActivationNumber;

		// The number of turns allotted to the side in the scenario.

		public int turns;

		// Whether or not the side sets up first.

		public boolean setsUpFirst;

		// Constructor

		/**
		 * Construct a new <CODE>OrderOfBattle</CODE> for the specified
		 * side.
		 *
		 * @param side the side (Allies or Axis) that the Units are
		 * fighting for.
		 * @param elr the experience level rating (ELR) of the Units.
		 * @param san the sniper activation number (SAN) for the side.
		 * @param turns the number of turns allotted to the side.
		 * @param setsUpFirst whether or not the side does so.
		 */

		public OrderOfBattle(Side.Sides side,int elr,int san,int turns,
		                     boolean setsUpFirst)
		{
			side = side;
			experienceLevelRating = elr;
			sniperActivationNumber = san;
			turns = turns;
			setsUpFirst = setsUpFirst;
		}
	}

	/**
	 */

	private class Formation
	{
		// The following items are set by corresponding arguments passed
		// to the constructor.

		// The name of the formation that the Units belong to.

		public String name;

		// The turn that the Units in this formation enter the game.
		//
		// A value of zero indicates that the Units must be positioned
		// before game play begins.

		public int entryTurn;

		// Constructor

		/**
		 * Construct a new <CODE>Formation</CODE>.
		 *
		 * @param name the title of the formation.
		 * @param entryTurn the turn that the Units in the formation
		 * enter the game.
		 */

		public Formation(String name,int entryTurn)
		{
			name = name;
			entryTurn = entryTurn;
		}
	}
}
