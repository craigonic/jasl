// ************************************************************************** //
// Scenario.java - This class is a member of the <B>ui.data</B> package, which       //
//                 contains the class definitions and implementations for     //
//                 objects used to store and manage the state of an instance  //
//                 of jASL.                                                   //
//                                                                            //
//                 NOTE: This program is based on Advanced Squad Leader,      //
//                       which was created by The Avalon Hill Game Company,   //
//                       and lives on at <A HREF="http://www.multimanpublishing.com/Products/tabid/58/CategoryID/4/Default.aspx">MultimanPublishing.com</A>.              //
//                                                                            //
// Written By: Craig R. Campbell  -  January 2016                             //
// ************************************************************************** //

package jasl.ui.data;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;

import org.json.JSONArray;
import org.json.JSONObject;

import jasl.counters.Description;
import jasl.utilities.Messages;

/**
 * This class is used to translate text data in the JSON format into the objects
 * and settings necessary to play a jASL scenario.
 *
 * @version 1.0
 * @author Copyright (C) 2016 Craig R. Campbell (craigonic@gmail.com)
 * @see <A HREF="../../../../source/jasl/ui/data/Scenario.html">Source code</A>
 */

public final class Scenario
{
	// The following items are set using values associated with (mostly?)
	// matching key names in the JSON input file.

	// The name of the scenario.

	private String _name;

	// The number of turns in the scenario.

	private int _turns;

	// The starting side in the scenario.

	private Side.Sides _startingSide = Side.Sides.ALLIES;

	// The following strings correspond to some of the "keys" used in the
	// JSON input data. The other keys are labels defined within the
	// counters package, see the toJSON() methods there for examples.

	private static final String NAME             = "name";
	private static final String TURNS            = "turns";
	private static final String STARTING_SIDE    = "starting side";
	private static final String SIDES_ARRAY      = "sides";
	private static final String SIDE             = "side";
	private static final String SAN_NUMBER       = "SAN";
	private static final String FORMATIONS_ARRAY = "formations";
	private static final String ENTRY_TURN       = "entry turn";
	private static final String UNITS_ARRAY      = "units";
	private static final String COPIES           = "copies";

	// The following strings are used as messages for any exceptions that
	// may be generated by bad data being passed one of the constructors.

	private static final String CLASS_NAME = Scenario.class.getSimpleName();

	private static final String nullPointerError =
		Messages.buildErrorMessage(CLASS_NAME,Messages.CONSTRUCTOR,
		                           Messages.NULL_PARAMETER_MSG);

	private static final String invalidArgumentError =
		Messages.buildErrorMessage(CLASS_NAME,Messages.CONSTRUCTOR,
		                           Messages.INVALID_PARAMETER_MSG);
	// Constructors

	/**
	 * Construct a new <CODE>Scenario</CODE>.
	 *
	 * This constructor processes the specified JSON input data, using it to
	 * generate the objects and settings that define a scenario. The input
	 * stream will be closed when all of the data has been read.
	 *
	 * @param inputStream the UTF-8 encoded JSON input data
	 *
	 * @throws NullPointerException in the case of a null InputStream
	 * argument.
	 * @throws IOException in the case where an error occurs while reading
	 * the input data stream.
	 * @throws Exception in the case where an error occurs while parsing the
	 * JSON data. This may be a JSONException or an
	 * IllegalArgumentException.
	 */

	public Scenario(InputStream inputStream) throws IOException
	{
		if (null == inputStream)
		{
			throw new NullPointerException(nullPointerError);
		}

		try
		{
			processInputStream(inputStream);
		}

		catch (Exception exception)
		{
			throw exception;
		}
	}

	/**
	 * Construct a new <CODE>Scenario</CODE>.
	 *
	 * This constructor performs the same function as the one that accepts
	 * an InputStream argument, with the added functionality of retrieving
	 * the data from the specified file.
	 *
	 * @param filename the name of the file containing the UTF-8
	 * encoded JSON input data
	 *
	 * @throws NullPointerException in the case of a null filename argument.
	 * @throws FileNotFoundException in the case where the file does not
	 * exist or cannot be read.
	 * @throws IOException in the case where an error occurs while reading
	 * the file.
	 * @throws Exception in the case where an error occurs while parsing the
	 * JSON data. This may be a JSONException or an
	 * IllegalArgumentException.
	 */

	public Scenario(String filename) throws IOException
	{
		if (null == filename)
		{
			throw new NullPointerException(nullPointerError);
		}

		try
		{
			processInputStream(new FileInputStream(filename));
		}

		catch (Exception exception)
		{
			throw exception;
		}
	}

	// Public access methods

	/**
	 * Return a text representation of the attributes of a scenario.
	 *
	 * @return a multi-line <CODE>String</CODE> specifying an overview of the elements of
	 * the scenario.
	 */

	public String toText()
	{
		StringBuffer returnString = new StringBuffer();

		returnString.append("Name:\t");
		returnString.append(toString());
		returnString.append("\n");

		returnString.append("Turns:\t");
		returnString.append(turns());

		returnString.append("\tStarting side:\t");
		returnString.append(startingSide().toString());
		returnString.append("\n");

		// Return the completed string to calling program.

		return returnString.toString();
	}

	/**
	 * Return the name of a scenario.
	 *
	 * @return a <CODE>String</CODE> specifying the scenario name.
	 */

	public String toString()
	{
		return _name;
	}

	/**
	 * Return the number of turns in a scenario.
	 *
	 * @return an <CODE>int</CODE> specifying the number of turns in the scenario.
	 */

	public int turns()
	{
		return _turns;
	}

	/**
	 * Return the starting side in a scenario.
	 *
	 * @return a <CODE>Side.Sides</CODE> specifying the starting side in the scenario.
	 */

	public Side.Sides startingSide()
	{
		return _startingSide;
	}

	// Private helper methods

	/**
	 * Translate the input data stream into a text string, which is
	 * subsequently parsed.
	 *
	 * This method is called from the constructors and does just what its
	 * name implies. When the read operation is complete, the input stream
	 * is closed and the String is passed to the parseJsonData() method.
	 *
	 * @param inputStream the UTF-8 encoded JSON input data
	 */

	private void processInputStream(InputStream inputStream) throws IOException
	{
		StringBuilder stringBuilder = new StringBuilder(2048);

		try
		{
			BufferedReader bufferedReader =
				new BufferedReader(new InputStreamReader(inputStream,
				                                         "UTF-8"));
			String inputString;

			while (null != (inputString = bufferedReader.readLine()))
			{
				stringBuilder.append(inputString);
			}

			inputStream.close();
		}

		catch (IOException exception)
		{
			throw exception;
		}

//		System.out.println("Input data:\n" + stringBuilder.toString());

		try
		{
			parseJsonData(stringBuilder.toString());
		}

		catch (Exception exception)
		{
			throw exception;
		}
	}

	/**
	 * Parse the specified JSON data and use it to generate the objects and
	 * settings that define the scenario.
	 *
	 * This method is called from processInputStream().
	 *
	 * @param jsonData the JSON data to be parsed
	 */

	private void parseJsonData(String jsonData)
	{
		try
		{
			// TODO: Validate JSON data using schema.

			JSONObject jsonObject = new JSONObject(jsonData);

			_name  = jsonObject.getString(NAME);
			_turns = jsonObject.getInt(TURNS);
			_startingSide =
				Side.Sides.values()[jsonObject.getInt(STARTING_SIDE)];

			JSONArray jsonArray = jsonObject.getJSONArray(SIDES_ARRAY);

			for (int i = 0;i < jsonArray.length();++i)
			{
				parseSideData(jsonArray.getJSONObject(i));
			}
		}

		catch (Exception exception)
		{
			throw exception;
		}
	}

	/**
	 * Parse the specified JSON data and use it to generate the objects and
	 * settings that define one side in a scenario.
	 *
	 * This method is called from parseJsonData(). The input data is used to
	 * populate a Scenario.OrderOfBattle object for the side.
	 *
	 * @param jsonObject the JSON data to be parsed
	 */

	private void parseSideData(JSONObject jsonObject)
	{
		try
		{
			Side.Sides side =
				Side.Sides.values()[jsonObject.getInt(SIDE)];
			int experienceLevelRating =
//				jsonObject.getInt(jasl.counters.Infantry.ELR_LABEL);
				jsonObject.getInt("Experience Level Rating");
			int sniperActivationNumber =
				jsonObject.getInt(SAN_NUMBER);

			OrderOfBattle orderOfBattle =
				new OrderOfBattle(side,experienceLevelRating,
				                  sniperActivationNumber);
			JSONArray jsonArray =
				jsonObject.getJSONArray(FORMATIONS_ARRAY);

			for (int i = 0;i < jsonArray.length();++i)
			{
				parseFormationData(jsonArray.getJSONObject(i));
			}
		}

		catch (Exception exception)
		{
			throw exception;
		}
	}

	/**
	 * Parse the specified JSON data and use it to generate the objects and
	 * settings associated with a formation (one or more groups of Units) on
	 * one side in a scenario.
	 *
	 * This method is called from parseSideData(). The input data is used to
	 * populate a Scenario.Formation object, which is returned to the
	 * caller.
	 * Map<Integer,List<Formation>> formationMap =
	 *     new HashMap<Integer,List<Formation>();
	 *
	 * @param jsonObject the JSON data to be parsed
	 */

	private void parseFormationData(JSONObject jsonObject)
	{
		try
		{
			String name   = jsonObject.getString(NAME);
			int entryTurn = 1;

			if (jsonObject.has(ENTRY_TURN))
			{
				entryTurn = jsonObject.getInt(ENTRY_TURN);

				if ((entryTurn < 1) || (entryTurn > _turns))
				{
					entryTurn = 1;
				}
			}

			Formation formation = new Formation(name,entryTurn);

			JSONArray jsonArray =
				jsonObject.getJSONArray(UNITS_ARRAY);

			for (int i = 0;i < jsonArray.length();++i)
			{
				parseUnitData(jsonArray.getJSONObject(i));
			}
		}

		catch (Exception exception)
		{
			throw exception;
		}
	}

	/**
	 * Parse the specified JSON data and use it to generate the Unit objects
	 * associated with a formation.
	 *
	 * This method is called from parseFormationData(). The input data is
	 * used to generate a list of Unit objects, which is returned to the
	 * caller.
	 *
	 * @param jsonObject the JSON data to be parsed
	 */

	private void parseUnitData(JSONObject jsonObject)
	{
		try
		{
			int copies = 1;

			if (jsonObject.has(COPIES))
			{
				copies = jsonObject.getInt(COPIES);

				if (copies < 1) copies = 1;
			}

//			Description.Descriptions description =
//				Description.Descriptions.valueOf(jsonObject.getString(Description.DESCRIPTION_LABEL));

//			List<Unit> units =
//				createUnitList(description,copies,jsonObject);
		}

		catch (Exception exception)
		{
			throw exception;
		}
	}

	/**
	 */

	private class OrderOfBattle
	{
		// The following items are set by corresponding arguments passed
		// to the constructor.

		// The side represented by the Units in an instance of this
		// class.

		private Side.Sides _side = Side.Sides.ALLIES;

		// Their experience level rating (ELR).

		private int _experienceLevelRating;

		// The sniper activation number (SAN).

		private int _sniperActivationNumber;

		// Constructors

		/**
		 * Construct a new <CODE>OrderOfBattle</CODE>.
		 *
		 * @param side the side (Allies or Axis) that the Units are
		 * fighting for.
		 * @param elr the experience level rating (ELR) of the Units.
		 * @param san the sniper activation number (SAN) for the side.
		 */

		public OrderOfBattle(Side.Sides side,int elr,int san)
		{
			_side = side;
			_experienceLevelRating = elr;
			_sniperActivationNumber = san;
		}
	}

	/**
	 */

	private class Formation
	{
		// The following items are set by corresponding arguments passed
		// to the constructor.

		// The name of the formation that the Units belong to.

		private String _name;

		// The turn that the Units in this formation enter the game.

		private int _entryTurn;

		// Constructors

		/**
		 * Construct a new <CODE>Formation</CODE>.
		 *
		 * @param name the title of the formation
		 * @param entryTurn the turn that the Units in the formation
		 * enter the game
		 */

		public Formation(String name,int entryTurn)
		{
			_name = name;
			_entryTurn = entryTurn;
		}
	}
}
